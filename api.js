import request from 'request-promise-native';
import fs from 'fs';
import moment from "moment";
import schedule from 'node-schedule';
import EventEmitter from 'events';
import winston from 'winston';
const log = winston.createLogger({
    exitOnError: true,
    transports: [
        new winston.transports.Console({
            level: process.env.logLevel || "error",
            format: winston.format.combine(winston.format.colorize(), winston.format.simple())
        })
    ]
});
const USERAGENT = process.env.npm_package_config_useragent || "nodejs - node-zdf-api-client";
export class ZDFApi extends EventEmitter {
    constructor(client, secret, apihost) {
        super();
        if (client == "")
            throw new Error(`invalid client ID`);
        if (secret == "")
            throw new Error(`invalid client secret`);
        if (apihost == "")
            throw new Error(`invalid api host`);
        this.client = client;
        this.secret = secret;
        this.host = apihost;
        //try restore from file
        this._token = this.loadTokenFile(); //retuns promise
    }
    //event version
    publishTokenE(token) {
        this.emit("token-ready", token);
    }
    //getter version
    get token() {
        return this._token; //return token promise
    }
    async loadTokenFile() {
        let filename = this.host + ".token.json";
        let oldtoken;
        let oldtokenvalid = false;
        if (fs.existsSync(filename)) {
            //have old token but verify it
            log.verbose("Using cached Token");
            try {
                oldtoken = JSON.parse(fs.readFileSync(filename, 'utf8'));
                oldtokenvalid = await this.verifyToken(oldtoken);
                if (oldtokenvalid === true) {
                    log.verbose("cached Token is valid");
                    //token valid return resolved promise
                    this.createTokenRefreshTask(oldtoken); //create task for old token
                    //trigger event
                    this.publishTokenE(oldtoken);
                    return Promise.resolve(oldtoken);
                }
            }
            catch (error) {
                log.warn("Token not readable");
                fs.unlink(filename, () => { });
            }
        }
        //cant load old token OR token outdated
        //request new token        
        return this.requestNewToken();
    }
    async verifyToken(token) {
        //part1
        return await request({
            url: `https://${this.host}/oauth/validate`,
            method: 'POST',
            auth: {
                user: this.client,
                pass: this.secret
            },
            headers: {
                'User-Agent': USERAGENT,
            },
            form: {
                'token': token.access_token
            },
            resolveWithFullResponse: true
        })
            .then((result) => result.statusCode == 200)
            .catch(() => false);
    }
    async requestNewToken() {
        log.verbose("request new Token");
        let result = await request({
            url: `https://${this.host}/oauth/token`,
            method: 'POST',
            auth: {
                user: this.client,
                pass: this.secret
            },
            headers: {
                'User-Agent': USERAGENT,
            },
            form: {
                'grant_type': 'client_credentials'
            }
        });
        try {
            let token = JSON.parse(result);
            token.outdatedAt = moment().add(token.expires_in, "seconds").subtract(1, "hour").format();
            this.saveTokenFile(token);
            this.createTokenRefreshTask(token); //create task for new token
            //trigger event
            this.publishTokenE(token);
            return Promise.resolve(token);
        }
        catch (error) {
            return Promise.reject("Failed to request new Token.");
        }
    }
    saveTokenFile(token) {
        let filename = this.host + ".token.json";
        fs.writeFile(filename, JSON.stringify(token), function (err) {
            if (err) {
                log.warning("Token not saved.", err);
                return;
            }
            log.verbose("Token saved");
        });
    }
    stopTokenRefreshTask() {
        //clear existing Task
        if (this.RefreshTask) {
            schedule.cancelJob(this.RefreshTask);
            log.debug("RefreshTask canceled");
        }
    }
    createTokenRefreshTask(token) {
        this.stopTokenRefreshTask();
        //token's max-age
        let outdatedAt = moment(token.outdatedAt).toDate();
        //create Token refresh Task
        this.RefreshTask = schedule.scheduleJob(outdatedAt, () => {
            this._token = this.requestNewToken(); //overwrite old promise with new one
        });
        log.debug("createdRefreshTask");
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sT0FBTyxNQUFNLHdCQUF3QixDQUFDO0FBQzdDLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxRQUFRLE1BQU0sZUFBZSxDQUFDO0FBQ3JDLE9BQU8sWUFBWSxNQUFNLFFBQVEsQ0FBQztBQUVsQyxPQUFPLE9BQU8sTUFBTSxTQUFTLENBQUM7QUFFOUIsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQztJQUM3QixXQUFXLEVBQUUsSUFBSTtJQUNqQixVQUFVLEVBQUU7UUFDVixJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDO1lBQzdCLEtBQUssRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsSUFBSSxPQUFPO1lBQ3RDLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FDNUIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFDekIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FDeEI7U0FDRixDQUFDO0tBQ0g7Q0FDRixDQUFDLENBQUM7QUFFTCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixJQUFJLDhCQUE4QixDQUFDO0FBVTdGLE1BQU0sT0FBTyxNQUFPLFNBQVEsWUFBWTtJQVNwQyxZQUFZLE1BQWEsRUFBRSxNQUFhLEVBQUUsT0FBYztRQUNwRCxLQUFLLEVBQUUsQ0FBQztRQUVSLElBQUssTUFBTSxJQUFJLEVBQUU7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDeEQsSUFBSyxNQUFNLElBQUksRUFBRTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUM1RCxJQUFLLE9BQU8sSUFB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QyxFQUFFLFVBQVMsR0FBUTtZQUMzRCxJQUFHLEdBQUcsRUFBRTtnQkFDSixHQUFHLENBQUMsT0FBTyxDQUFDLGtCQUFrQixFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNyQyxPQUFPO2FBQ1Y7WUFDRCxHQUFHLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELG9CQUFvQjtRQUNoQixxQkFBcUI7UUFDckIsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFDO1lBQ2pCLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3JDLEdBQUcsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQTtTQUNwQztJQUNMLENBQUM7SUFFRCxzQkFBc0IsQ0FBQyxLQUFhO1FBRWhDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBRTVCLGlCQUFpQjtRQUNqQixJQUFJLFVBQVUsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRW5ELDJCQUEyQjtRQUMzQixJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLEdBQUcsRUFBRTtZQUNyRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLG9DQUFvQztRQUM5RSxDQUFDLENBQUMsQ0FBQztRQUVILEdBQUcsQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUNwQyxDQUFDO0NBTUoiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWVzdCBmcm9tICdyZXF1ZXN0LXByb21pc2UtbmF0aXZlJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgbW9tZW50IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCBzY2hlZHVsZSBmcm9tICdub2RlLXNjaGVkdWxlJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcblxuaW1wb3J0IHdpbnN0b24gZnJvbSAnd2luc3Rvbic7XG5cbmNvbnN0IGxvZyA9IHdpbnN0b24uY3JlYXRlTG9nZ2VyKHtcbiAgICBleGl0T25FcnJvcjogdHJ1ZSxcbiAgICB0cmFuc3BvcnRzOiBbXG4gICAgICBuZXcgd2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUoe1xuICAgICAgICBsZXZlbDogcHJvY2Vzcy5lbnYubG9nTGV2ZWwgfHwgXCJlcnJvclwiLFxuICAgICAgICBmb3JtYXQ6IHdpbnN0b24uZm9ybWF0LmNvbWJpbmUoXG4gICAgICAgICAgd2luc3Rvbi5mb3JtYXQuY29sb3JpemUoKSxcbiAgICAgICAgICB3aW5zdG9uLmZvcm1hdC5zaW1wbGUoKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG5cbmNvbnN0IFVTRVJBR0VOVCA9IHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX2NvbmZpZ191c2VyYWdlbnQgfHwgXCJub2RlanMgLSBub2RlLXpkZi1hcGktY2xpZW50XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRva2VuIHtcbiAgICB0b2tlbl90eXBlOiBzdHJpbmdcbiAgICBleHBpcmVzX2luOiBudW1iZXJcbiAgICBhY2Nlc3NfdG9rZW46IHN0cmluZ1xuICAgIG91dGRhdGVkQXQ6IERhdGUgfCBzdHJpbmdcbiAgICBbcHJvcE5hbWU6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgY2xhc3MgWkRGQXBpIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAgIHByaXZhdGUgY2xpZW50OiBzdHJpbmdcbiAgICBwcml2YXRlIHNlY3JldDogc3RyaW5nXG4gICAgcHJpdmF0ZSBob3N0OiBzdHJpbmdcbiAgICBwcml2YXRlIF90b2tlbjogUHJvbWlzZTxJVG9rZW4+XG4gICAgXG4gICAgUmVmcmVzaFRhc2s6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGNsaWVudDpzdHJpbmcsIHNlY3JldDpzdHJpbmcsIGFwaWhvc3Q6c3RyaW5nKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBpZiAoIGNsaWVudCA9PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY2xpZW50IElEYCk7XG4gICAgICAgIGlmICggc2VjcmV0ID09IFwiXCIpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjbGllbnQgc2VjcmV0YCk7XG4gICAgICAgIGlmICggYXBpaG9zdCA9PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYXBpIGhvc3RgKTtcblxuICAgICAgICB0aGlzLmNsaWVudCAgPSBjbGllbnQgXG4gICAgICAgIHRoaXMuc2VjcmV0ICA9IHNlY3JldCBcbiAgICAgICAgdGhpcy5ob3N0ID0gYXBpaG9zdFxuXG4gICAgICAgIC8vdHJ5IHJlc3RvcmUgZnJvbSBmaWxlXG4gICAgICAgIHRoaXMuX3Rva2VuID0gdGhpcy5sb2FkVG9rZW5GaWxlKCkgLy9yZXR1bnMgcHJvbWlzZVxuICAgICAgICBcbiAgICB9XG5cbiAgICAvL2V2ZW50IHZlcnNpb25cbiAgICBwdWJsaXNoVG9rZW5FKHRva2VuOklUb2tlbil7XG4gICAgICAgIHRoaXMuZW1pdChcInRva2VuLXJlYWR5XCIsdG9rZW4pO1xuICAgIH1cblxuICAgIC8vZ2V0dGVyIHZlcnNpb25cbiAgICBnZXQgdG9rZW4oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuOyAvL3JldHVybiB0b2tlbiBwcm9taXNlXG4gICAgfVxuXG4gICAgXG5cblxuICAgIGFzeW5jIGxvYWRUb2tlbkZpbGUoKXtcbiAgICAgICAgXG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHRoaXMuaG9zdCArIFwiLnRva2VuLmpzb25cIjtcbiAgICAgICAgbGV0IG9sZHRva2VuOklUb2tlbjtcbiAgICAgICAgbGV0IG9sZHRva2VudmFsaWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlbmFtZSkpe1xuICAgICAgICBcbiAgICAgICAgICAgIC8vaGF2ZSBvbGQgdG9rZW4gYnV0IHZlcmlmeSBpdFxuICAgICAgICAgICAgbG9nLnZlcmJvc2UoXCJVc2luZyBjYWNoZWQgVG9rZW5cIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZHRva2VuID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICAgICAgZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpXG4gICAgICAgICAgICAgICAgKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgb2xkdG9rZW52YWxpZCA9IGF3YWl0IHRoaXMudmVyaWZ5VG9rZW4oIG9sZHRva2VuICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKG9sZHRva2VudmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLnZlcmJvc2UoXCJjYWNoZWQgVG9rZW4gaXMgdmFsaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3Rva2VuIHZhbGlkIHJldHVybiByZXNvbHZlZCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9rZW5SZWZyZXNoVGFzayggb2xkdG9rZW4gKTsgLy9jcmVhdGUgdGFzayBmb3Igb2xkIHRva2VuXG4gICAgICAgICAgICAgICAgICAgIC8vdHJpZ2dlciBldmVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hUb2tlbkUoIG9sZHRva2VuICk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBvbGR0b2tlbiApO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihcIlRva2VuIG5vdCByZWFkYWJsZVwiKTtcbiAgICAgICAgICAgICAgICBmcy51bmxpbmsoZmlsZW5hbWUsKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy9jYW50IGxvYWQgb2xkIHRva2VuIE9SIHRva2VuIG91dGRhdGVkXG4gICAgICAgIC8vcmVxdWVzdCBuZXcgdG9rZW4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TmV3VG9rZW4oKTtcbiAgICBcbiAgICB9XG5cbiAgICBhc3luYyB2ZXJpZnlUb2tlbih0b2tlbjogSVRva2VuKXtcblxuICAgICAgICAvL3BhcnQxXG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0KHtcbiAgICAgICAgICAgIHVybDogYGh0dHBzOi8vJHt0aGlzLmhvc3R9L29hdXRoL3ZhbGlkYXRlYCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgICAgIHVzZXI6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhc3M6IHRoaXMuc2VjcmV0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogVVNFUkFHRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm06IHtcbiAgICAgICAgICAgICAgICAndG9rZW4nOiB0b2tlbi5hY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNvbHZlV2l0aEZ1bGxSZXNwb25zZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAudGhlbiggKHJlc3VsdDogeyBzdGF0dXNDb2RlOiBudW1iZXI7IH0pID0+IHJlc3VsdC5zdGF0dXNDb2RlPT0yMDAgKVxuICAgICAgICAuY2F0Y2goICgpPT4gZmFsc2UgKTsgICAgXG5cbiAgICB9XG5cblxuICAgIGFzeW5jIHJlcXVlc3ROZXdUb2tlbigpe1xuICAgICAgICBcbiAgICAgICAgbG9nLnZlcmJvc2UoXCJyZXF1ZXN0IG5ldyBUb2tlblwiKTtcblxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IGBodHRwczovLyR7dGhpcy5ob3N0fS9vYXV0aC90b2tlbmAsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgICAgICB1c2VyOiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXNzOiB0aGlzLnNlY3JldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IFVTRVJBR0VOVCxcbiAgICAgICAgICAgIH0sICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgICAgICAgJ2dyYW50X3R5cGUnOiAnY2xpZW50X2NyZWRlbnRpYWxzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICB0b2tlbi5vdXRkYXRlZEF0ID0gbW9tZW50KCkuYWRkKHRva2VuLmV4cGlyZXNfaW4sXCJzZWNvbmRzXCIpLnN1YnRyYWN0KDEsXCJob3VyXCIpLmZvcm1hdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNhdmVUb2tlbkZpbGUodG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUb2tlblJlZnJlc2hUYXNrKHRva2VuKTsgLy9jcmVhdGUgdGFzayBmb3IgbmV3IHRva2VuXG5cbiAgICAgICAgICAgIC8vdHJpZ2dlciBldmVudFxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoVG9rZW5FKCB0b2tlbiApOyAgICAgICAgICAgIFxuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRva2VuKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiRmFpbGVkIHRvIHJlcXVlc3QgbmV3IFRva2VuLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNhdmVUb2tlbkZpbGUodG9rZW46IElUb2tlbil7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHRoaXMuaG9zdCArIFwiLnRva2VuLmpzb25cIjsgICAgICAgXG5cbiAgICAgICAgZnMud3JpdGVGaWxlKGZpbGVuYW1lLCBKU09OLnN0cmluZ2lmeSh0b2tlbiksIGZ1bmN0aW9uKGVycjogYW55KSB7XG4gICAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybmluZyhcIlRva2VuIG5vdCBzYXZlZC5cIiwgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cudmVyYm9zZShcIlRva2VuIHNhdmVkXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgc3RvcFRva2VuUmVmcmVzaFRhc2soKXtcbiAgICAgICAgLy9jbGVhciBleGlzdGluZyBUYXNrXG4gICAgICAgIGlmICh0aGlzLlJlZnJlc2hUYXNrKXtcbiAgICAgICAgICAgIHNjaGVkdWxlLmNhbmNlbEpvYih0aGlzLlJlZnJlc2hUYXNrKTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlJlZnJlc2hUYXNrIGNhbmNlbGVkXCIpXG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cblxuICAgIGNyZWF0ZVRva2VuUmVmcmVzaFRhc2sodG9rZW46IElUb2tlbil7XG5cbiAgICAgICAgdGhpcy5zdG9wVG9rZW5SZWZyZXNoVGFzaygpO1xuICAgICAgICBcbiAgICAgICAgLy90b2tlbidzIG1heC1hZ2VcbiAgICAgICAgbGV0IG91dGRhdGVkQXQgPSBtb21lbnQodG9rZW4ub3V0ZGF0ZWRBdCkudG9EYXRlKCk7XG5cbiAgICAgICAgLy9jcmVhdGUgVG9rZW4gcmVmcmVzaCBUYXNrXG4gICAgICAgIHRoaXMuUmVmcmVzaFRhc2sgPSBzY2hlZHVsZS5zY2hlZHVsZUpvYihvdXRkYXRlZEF0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IHRoaXMucmVxdWVzdE5ld1Rva2VuKCk7IC8vb3ZlcndyaXRlIG9sZCBwcm9taXNlIHdpdGggbmV3IG9uZVxuICAgICAgICB9KTtcblxuICAgICAgICBsb2cuZGVidWcoXCJjcmVhdGVkUmVmcmVzaFRhc2tcIik7XG4gICAgfVxuXG5cblxuXG5cbn1cblxuIl19